// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/xescugc/chaoswall/wall (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	wall "github.com/xescugc/chaoswall/wall"
	reflect "reflect"
)

// WallRepository is a mock of Repository interface
type WallRepository struct {
	ctrl     *gomock.Controller
	recorder *WallRepositoryMockRecorder
}

// WallRepositoryMockRecorder is the mock recorder for WallRepository
type WallRepositoryMockRecorder struct {
	mock *WallRepository
}

// NewWallRepository creates a new mock instance
func NewWallRepository(ctrl *gomock.Controller) *WallRepository {
	mock := &WallRepository{ctrl: ctrl}
	mock.recorder = &WallRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *WallRepository) EXPECT() *WallRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method
func (m *WallRepository) Create(arg0 context.Context, arg1 string, arg2 wall.Wall) (uint32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", arg0, arg1, arg2)
	ret0, _ := ret[0].(uint32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create
func (mr *WallRepositoryMockRecorder) Create(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*WallRepository)(nil).Create), arg0, arg1, arg2)
}

// DeleteByCanonical mocks base method
func (m *WallRepository) DeleteByCanonical(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByCanonical", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteByCanonical indicates an expected call of DeleteByCanonical
func (mr *WallRepositoryMockRecorder) DeleteByCanonical(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByCanonical", reflect.TypeOf((*WallRepository)(nil).DeleteByCanonical), arg0, arg1, arg2)
}

// FilterWithHolds mocks base method
func (m *WallRepository) FilterWithHolds(arg0 context.Context, arg1 string) ([]*wall.WithHolds, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterWithHolds", arg0, arg1)
	ret0, _ := ret[0].([]*wall.WithHolds)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FilterWithHolds indicates an expected call of FilterWithHolds
func (mr *WallRepositoryMockRecorder) FilterWithHolds(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterWithHolds", reflect.TypeOf((*WallRepository)(nil).FilterWithHolds), arg0, arg1)
}

// FindByCanonicalWithHolds mocks base method
func (m *WallRepository) FindByCanonicalWithHolds(arg0 context.Context, arg1, arg2 string) (*wall.WithHolds, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByCanonicalWithHolds", arg0, arg1, arg2)
	ret0, _ := ret[0].(*wall.WithHolds)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByCanonicalWithHolds indicates an expected call of FindByCanonicalWithHolds
func (mr *WallRepositoryMockRecorder) FindByCanonicalWithHolds(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByCanonicalWithHolds", reflect.TypeOf((*WallRepository)(nil).FindByCanonicalWithHolds), arg0, arg1, arg2)
}

// UpdateByCanonical mocks base method
func (m *WallRepository) UpdateByCanonical(arg0 context.Context, arg1, arg2 string, arg3 wall.Wall) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateByCanonical", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateByCanonical indicates an expected call of UpdateByCanonical
func (mr *WallRepositoryMockRecorder) UpdateByCanonical(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateByCanonical", reflect.TypeOf((*WallRepository)(nil).UpdateByCanonical), arg0, arg1, arg2, arg3)
}
